[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Main",
    "section": "",
    "text": "I’ll be doing the Advent of Code 2022 here. I’ll probably be late most days. R+tidyverse is my preferred language, but might dip into some python as needed.\n\n\n\n\n\n\n\n\n  \n\n\n\n\nDay 1\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\n\n\n\n\n\n\n\n\n\nDec 1, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 2\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\n\n\n\n\n\n\n\n\n\nDec 2, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 3\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\nstringr\n\n\n\n\n\n\n\n\n\n\n\nDec 3, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 4\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\n\n\n\n\n\n\n\n\n\nDec 4, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDay 5\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "days/2022-12-5.html",
    "href": "days/2022-12-5.html",
    "title": "Day 5",
    "section": "",
    "text": "I think for preprocessing the text, I’m going to start off with python.\n\n```{r}\nlibrary(reticulate)\n```\n\n\n```{python}\nwith open(\"2022-12-5_assets/input.txt\", \"r\") as data:\n  lines = data.readlines()\n```\n\n\n\n\n```{python}\ninitial_state = [x.replace(\"\\n\", \"\") \n                  for x in lines \n                    if \"move\" not in x and len(x) > 1]\ninitial_state\n```\n\n['[N]     [C]                 [Q]    ', '[W]     [J] [L]             [J] [V]', '[F]     [N] [D]     [L]     [S] [W]', '[R] [S] [F] [G]     [R]     [V] [Z]', '[Z] [G] [Q] [C]     [W] [C] [F] [G]', '[S] [Q] [V] [P] [S] [F] [D] [R] [S]', '[M] [P] [R] [Z] [P] [D] [N] [N] [M]', '[D] [W] [W] [F] [T] [H] [Z] [W] [R]', ' 1   2   3   4   5   6   7   8   9 ']\n\n\nThere’s not a fixed delimiter between every column. Each column is 3 characters wide, with a space in between.\n\n```{python}\n[len(x) for x in initial_state]\n```\n\n[35, 35, 35, 35, 35, 35, 35, 35, 35]\n\n\n\n```{python}\ndef three_split(x):\n  out = []\n  start = 0\n  done = False\n  while not done:\n    end = start + 3\n    item = x[start:end].strip()\n    out.append(item)\n    start = end + 1\n    if start > len(x):\n      done = True\n  return(out)\n```\n\n\n```{python}\nstate_rows = [three_split(x) for x in initial_state]\nstate_rows\n```\n\n[['[N]', '', '[C]', '', '', '', '', '[Q]', ''], ['[W]', '', '[J]', '[L]', '', '', '', '[J]', '[V]'], ['[F]', '', '[N]', '[D]', '', '[L]', '', '[S]', '[W]'], ['[R]', '[S]', '[F]', '[G]', '', '[R]', '', '[V]', '[Z]'], ['[Z]', '[G]', '[Q]', '[C]', '', '[W]', '[C]', '[F]', '[G]'], ['[S]', '[Q]', '[V]', '[P]', '[S]', '[F]', '[D]', '[R]', '[S]'], ['[M]', '[P]', '[R]', '[Z]', '[P]', '[D]', '[N]', '[N]', '[M]'], ['[D]', '[W]', '[W]', '[F]', '[T]', '[H]', '[Z]', '[W]', '[R]'], ['1', '2', '3', '4', '5', '6', '7', '8', '9']]\n\n\nI had a big hang up here, because I created the list of empty lists with [[]] * 9, which copies the empty list, so when I appended a value to columns[0], it appended that value to all columns.\n\n```{python}\ncolumns = [[] for _ in range(len(state_rows[0]))]\nfor ridx, row in enumerate(state_rows):\n  for cidx, col in enumerate(state_rows[ridx]):\n    if len(col) > 0 :\n      columns[cidx].append(col)\n    \nprint(columns)\n```\n\n[['[N]', '[W]', '[F]', '[R]', '[Z]', '[S]', '[M]', '[D]', '1'], ['[S]', '[G]', '[Q]', '[P]', '[W]', '2'], ['[C]', '[J]', '[N]', '[F]', '[Q]', '[V]', '[R]', '[W]', '3'], ['[L]', '[D]', '[G]', '[C]', '[P]', '[Z]', '[F]', '4'], ['[S]', '[P]', '[T]', '5'], ['[L]', '[R]', '[W]', '[F]', '[D]', '[H]', '6'], ['[C]', '[D]', '[N]', '[Z]', '7'], ['[Q]', '[J]', '[S]', '[V]', '[F]', '[R]', '[N]', '[W]', '8'], ['[V]', '[W]', '[Z]', '[G]', '[S]', '[M]', '[R]', '9']]\n\n\n\n\n\n\n```{python}\nmove_instructions = [x.strip() for x in lines if \"move\" in x]\n```\n\n\n```{python}\nimport re\nmove_list = [re.findall(r'\\d+', line) \n              for line in move_instructions]\nmove_int = [[int(x[0]), int(x[1])-1, int(x[2])-1] \n              for x in move_list]\n```\n\n\n```{python}\ndef move_fun(m):\n  n = m[0]\n  fro = move[1]\n  to = move[2]\n  for i in range(n):\n    columns[to].insert(0, columns[fro].pop(0))\n```\n\n\n```{python}\nfor move in move_int:\n  move_fun(move)\n```\n\n\n```{python}\n\"\".join([x[0].replace(\"[\", \"\").replace(\"]\", \"\") for x in columns])\n```\n\n'FWNSHLDNZ'"
  },
  {
    "objectID": "days/2022-12-4.html",
    "href": "days/2022-12-4.html",
    "title": "Day 4",
    "section": "",
    "text": "Part 1\nGiven two ranges of numbers, we need to find how many ranges have a complete overlap.\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\ndata <- read_csv(\"2022-12-4_assets/input.txt\", col_names = FALSE)\n\nRows: 1000 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): X1, X2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nelf_ranges <- \n  data |>\n  separate(\n    X1, \n    into = c(\"elf1_start\", \"elf1_end\"),\n    convert = TRUE\n  ) |>\n  separate(\n    X2,\n    into = c(\"elf2_start\", \"elf2_end\"),\n    convert = TRUE\n  )\n\nFor two ranges of numbers, they overlap if\nx1   .....   x2\n   y1  .......  y2\n   \nx1 <= y2\ny1 <= x2\n\noverlaps <- \n  elf_ranges |>\n  filter(elf1_start <= elf2_end,\n         elf2_start <= elf1_end)\n\nI think I have to use disjunction to find complete containment? Either\nx1 .......... x2\n   y1 ... y2\n   \nx1 <= y1 & x2 >= y2 || y1 <= x1 & y2 >= x2\n\noverlaps |>\n  filter((elf1_start <= elf2_start & elf1_end >= elf2_end) | \n           (elf2_start <= elf1_start & elf2_end >= elf1_end)) |>\n  nrow()\n\n[1] 441\n\n\n\n\nPart 2\nHah! Got the number of overlaps first!\n\noverlaps |> nrow()\n\n[1] 861\n\n\n\n\nJust for Fun\n\nlibrary(showtext)\n\nLoading required package: sysfonts\n\n\nLoading required package: showtextdb\n\nlibrary(ggdark)\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nlibrary(khroma)\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nshowtext_auto()\n\ntheme_set(dark_theme_gray() + \n            theme(title = element_text(family = \"christmas\", size = 20)))\n\nInverted geom defaults of fill and color/colour.\nTo change them back, use invert_geom_defaults().\n\n\n\noverlaps |>\n  rowwise() |>\n  mutate(overlap_start = max(c(elf1_start, elf2_start)),\n         overlap_end = min(c(elf1_end, elf2_end)),\n         overlap_df = map2(overlap_start, overlap_end, ~tibble(position = .x:.y))) |>\n  select(overlap_df) |>\n  unnest(overlap_df) |>\n  ggplot(aes(position))+\n    stat_bin(binwidth = 1,\n             aes(y = after_stat(count), \n                 fill = after_stat(count))) +\n    stat_density(aes(y = after_stat(count),\n                     linewidth = after_stat(count)), \n                 geom = \"path\")+\n    scale_fill_oslo(guide = \"none\")+\n    scale_linewidth(guide = \"none\")+\n    labs(title = \"overlap by position\")\n\n\n\n\nFigure 1: Degree of overlap by position"
  },
  {
    "objectID": "days/2022-12-1.html",
    "href": "days/2022-12-1.html",
    "title": "Day 1",
    "section": "",
    "text": "Source: https://adventofcode.com/2022/day/1"
  },
  {
    "objectID": "days/2022-12-1.html#puzzle-text",
    "href": "days/2022-12-1.html#puzzle-text",
    "title": "Day 1",
    "section": "Puzzle Text",
    "text": "Puzzle Text\n\n--- Day 1: Calorie Counting ---\nSanta’s reindeer […]\nThe Elves take turns writing down the number of Calories contained by the various meals, snacks, rations, etc. that they’ve brought with them, one item per line. Each Elf separates their own inventory from the previous Elf’s inventory (if any) by a blank line.\nFor example, suppose the Elves finish writing their items’ Calories and end up with the following list:\n1000 \n2000 \n3000\n\n4000\n\n5000 \n6000\n\n7000 \n8000 \n9000\n\n10000\nThis list represents the Calories of the food carried by five Elves:\n\n\n\nThe first Elf is carrying food with 1000, 2000, and 3000 Calories, a total of 6000 Calories.\n\n\n\nThe second Elf is carrying one food item with 4000 Calories.\n\n\n\nThe third Elf is carrying food with 5000 and 6000 Calories, a total of 11000 Calories.\nThe fourth Elf is carrying food with 7000, 8000, and 9000 Calories, a total of 24000 Calories.\nThe fifth Elf is carrying one food item with 10000 Calories.\n\nIn case the Elves get hungry and need extra snacks, they need to know which Elf to ask: they’d like to know how many Calories are being carried by the Elf carrying the most Calories. In the example above, this is 24000 (carried by the fourth Elf).\nFind the Elf carrying the most Calories. How many total Calories is that Elf carrying?"
  },
  {
    "objectID": "days/2022-12-1.html#r-session-info",
    "href": "days/2022-12-1.html#r-session-info",
    "title": "Day 1",
    "section": "R Session Info",
    "text": "R Session Info\n\nsessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.30     jsonlite_1.8.3    magrittr_2.0.3    evaluate_0.17    \n [5] rlang_1.0.6       stringi_1.7.8     cli_3.4.1         renv_0.15.5      \n [9] rstudioapi_0.14   rmarkdown_2.17    tools_4.2.1       stringr_1.4.1    \n[13] htmlwidgets_1.5.4 xfun_0.34         yaml_2.3.6        fastmap_1.1.0    \n[17] compiler_4.2.1    htmltools_0.5.3   knitr_1.40       \n\n\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(knitr)\nlibrary(kableExtra)\n\n\nAttaching package: 'kableExtra'\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows"
  },
  {
    "objectID": "days/2022-12-1.html#loading-data",
    "href": "days/2022-12-1.html#loading-data",
    "title": "Day 1",
    "section": "Loading Data",
    "text": "Loading Data\nFirst attempts at read_csv() were problematic because blank lines were ignored. skip_empty_rows = TRUE by default.\n\ncalories <- \n  read_csv(\n    \"2022-12-1_assets/input.txt\", \n    col_names = FALSE,\n    skip_empty_rows = FALSE\n    )\n\nRows: 2223 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (1): X1\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nDouble checking there are enough NAs.\n\ncalories |>\n  count(is.na(X1)) |>\n  kbl() |>\n  kable_styling(full_width = FALSE)\n\n\n\n \n  \n    is.na(X1) \n    n \n  \n \n\n  \n    FALSE \n    2000 \n  \n  \n    TRUE \n    223"
  },
  {
    "objectID": "days/2022-12-1.html#strategy",
    "href": "days/2022-12-1.html#strategy",
    "title": "Day 1",
    "section": "Strategy",
    "text": "Strategy\nI’ll identify the rows with NA and fill them with the row index. Then fill downward. I’ll need a special rule for the first row.\n\ncalories |>\n  ## a unique id for each elf.\n  ## won't increment by 1, but will be unique\n  mutate(\n    row_idx = 1:n(),\n    elf_id = case_when(\n      is.na(X1) ~ row_idx,  \n      row_idx == 1 ~ row_idx\n    )\n  ) |>\n  ## fill in the elf id for all rows\n  fill(elf_id) |>\n  ## drop na values for summarising\n  drop_na() |>\n  ## group_by, summarise, arrange\n  group_by(elf_id) |>\n  summarise(total_calories = sum(X1)) |>\n  arrange(desc(total_calories)) |>\n  ## pull the top number \n  slice(1) |>\n  pull(total_calories)\n\n[1] 70764"
  },
  {
    "objectID": "days/2022-12-1.html#just-for-fun",
    "href": "days/2022-12-1.html#just-for-fun",
    "title": "Day 1",
    "section": "Just for fun",
    "text": "Just for fun\n\nlibrary(showtext)\n\nLoading required package: sysfonts\n\n\nLoading required package: showtextdb\n\nlibrary(ggdark)\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nlibrary(khroma)\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nshowtext_auto()\n\n\ntotal_calories <- \n  calories |>\n    ## a unique id for each elf.\n    ## won't increment by 1, but will be unique\n    mutate(\n      row_idx = 1:n(),\n      elf_id = case_when(\n        is.na(X1) ~ row_idx,  \n        row_idx == 1 ~ row_idx\n      )\n    ) |>\n    ## fill in the elf id for all rows\n    fill(elf_id) |>\n    ## drop na values for summarising\n    drop_na() |>\n    ## group_by, summarise, arrange\n    group_by(elf_id) |>\n    summarise(total_calories = sum(X1)) |>\n    arrange(desc(total_calories)) |>\n    mutate(rank = 1:n())\n\n\ntotal_calories |>\n  ggplot(aes(rank, total_calories)) + \n    geom_point()+\n    scale_x_continuous(labels = label_comma())+\n    scale_y_continuous(labels = label_comma())+\n    labs(title = \"Total calories per elf\")+\n    dark_theme_gray()+\n    theme(title = element_text(family = \"christmas\", size = 20))\n\n\n\n\nFigure 1: total calories by rank\n\n\n\n\n\ntotal_calories |>\n  arrange(elf_id) |>\n  mutate(elf_order = 1:n()) |>\n  ggplot(aes(elf_order, total_calories, color = rank)) + \n    geom_point()+\n    scale_x_continuous(labels = label_comma())+\n    scale_y_continuous(labels = label_comma())+\n    scale_color_oslo(reverse = TRUE) +\n    guides(colour = guide_colourbar(reverse = TRUE))+\n    labs(title = \"Total calories per elf\")+\n    dark_theme_gray()+\n    theme(title = element_text(family = \"christmas\", size = 20))\n\n\n\n\nFigure 2: total calories by order"
  },
  {
    "objectID": "days/2022-12-3.html",
    "href": "days/2022-12-3.html",
    "title": "Day 3",
    "section": "",
    "text": "Source: https://adventofcode.com/2022/day/3"
  },
  {
    "objectID": "days/2022-12-3.html#description",
    "href": "days/2022-12-3.html#description",
    "title": "Day 3",
    "section": "Description:",
    "text": "Description:\nGiven a string of letters, we need to split them in half, and then find the single letter in common between them. Each letter is assigned a score, and then we need to sum them up.\nI think I’ll rely on stringr for this?\n\nsessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.30     jsonlite_1.8.3    magrittr_2.0.3    evaluate_0.17    \n [5] rlang_1.0.6       stringi_1.7.8     cli_3.4.1         renv_0.15.5      \n [9] rstudioapi_0.14   rmarkdown_2.17    tools_4.2.1       stringr_1.4.1    \n[13] htmlwidgets_1.5.4 xfun_0.34         yaml_2.3.6        fastmap_1.1.0    \n[17] compiler_4.2.1    htmltools_0.5.3   knitr_1.40       \n\n\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\ninput <- read_tsv(\n  \"2022-12-3_assets/input.txt\", \n  col_names = FALSE\n)\n\nRows: 300 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (1): X1\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\ncompartment <- \n  input |>\n  mutate(\n    # Get a total character count\n    n = nchar(X1),\n    # split the whole character string into a list\n    item_list = map(X1, ~str_split(.x, pattern = \"\", simplify = TRUE)),\n    # get the vector for the first half\n    compartment1 = map2(item_list, n, ~.x[1:(.y/2)]),\n    # get the vector for the second half\n    compartment2 = map2(item_list, n, ~.x[((.y/2)+1):.y]),\n    # get the shared values\n    shared = map2(compartment1, compartment2, ~.x[.x %in% .y])\n  ) \n\nAt this point, there are some values in shared are longer than 1. I need to check on those\n\ncompartment |>\n  mutate(n_shared = map(shared, length) |> simplify()) |>\n  filter(n_shared > 1) |>\n  sample_n(size = 5) |>\n  pull(shared)\n\n[[1]]\n[1] \"R\" \"R\"\n\n[[2]]\n[1] \"V\" \"V\"\n\n[[3]]\n[1] \"z\" \"z\"\n\n[[4]]\n[1] \"n\" \"n\"\n\n[[5]]\n[1] \"w\" \"w\" \"w\"\n\n\nI see, they’re repeated. I’ll uniquify and see if it’s all just length 1\n\ncompartment |>\n  mutate(unique_shared = map(shared, unique),\n         n_unique = map(unique_shared, length) |> simplify()) |>\n  filter(n_unique !=  1)\n\n# A tibble: 0 × 8\n# … with 8 variables: X1 <chr>, n <int>, item_list <list>, compartment1 <list>,\n#   compartment2 <list>, shared <list>, unique_shared <list>, n_unique <int>\n\n\nOk, good to go.\n\nshared_item_df <- \n  compartment |>\n  mutate(unique_shared = map(shared, unique) |> simplify()) \n\nI’ll use named vectors again to get the scores.\n\nitem_score = (1:52) |> set_names(c(letters, LETTERS))\n\n\nshared_item_df |>\n  mutate(priority = item_score[unique_shared]) |>\n  summarise(priority = sum(priority))\n\n# A tibble: 1 × 1\n  priority\n     <int>\n1     7763"
  },
  {
    "objectID": "days/2022-12-3.html#just-for-fun",
    "href": "days/2022-12-3.html#just-for-fun",
    "title": "Day 3",
    "section": "Just for fun",
    "text": "Just for fun\n\nlibrary(ggdark)\nlibrary(khroma)\nlibrary(showtext)\n\nLoading required package: sysfonts\n\n\nLoading required package: showtextdb\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nshowtext_auto()\n\ntheme_set(dark_theme_gray() + \n            theme(title = element_text(family = \"christmas\", size = 20)))\n\nInverted geom defaults of fill and color/colour.\nTo change them back, use invert_geom_defaults().\n\n\n\ngroup_coding |>\n  group_by(group) |>\n  summarise(shared = multi_in(item_list) |> unique(),\n            priority = item_score[shared]) |>\n  group_by(shared) |>\n  summarise(n = n(),\n            group_priority = priority[1],\n            total_priority = sum(priority)) |>\n  ggplot(aes(group_priority, n))+\n    geom_col(fill = \"lightblue\", color = \"white\")+\n    labs(title = \"count of priority groups\")\n\n\n\n\nFigure 1: the number of groups with a given priority\n\n\n\n\n\nknitr::knit_hooks$set(crop = knitr::hook_pdfcrop)\n\n\ngroup_coding |>\n  group_by(group) |>\n  summarise(shared = multi_in(item_list) |> unique(),\n            priority = item_score[shared]) |>\n  group_by(shared) |>\n  summarise(n = n(),\n            group_priority = priority[1],\n            total_priority = sum(priority)) |>\n  arrange(group_priority) |>\n ggplot(aes(\"x\", n))+\n    geom_col(aes(fill = group_priority),\n             color = \"white\",\n             position = \"fill\")+\n    scale_fill_oslo()+\n    labs(title = \"proportion of priority groups\",\n         x = NULL,\n         y = NULL)+\n    coord_polar(theta = \"y\")+\n    theme(axis.text.y = element_blank(),\n          axis.ticks.y = element_blank())\n\n\n\n\nFigure 2: the proportion of groups with a given priority"
  },
  {
    "objectID": "days/2022-12-2.html",
    "href": "days/2022-12-2.html",
    "title": "Day 2",
    "section": "",
    "text": "source: https://adventofcode.com/2022/day/2\nRock paper scissors setup\n\nsessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.30     jsonlite_1.8.3    magrittr_2.0.3    evaluate_0.17    \n [5] rlang_1.0.6       stringi_1.7.8     cli_3.4.1         renv_0.15.5      \n [9] rstudioapi_0.14   rmarkdown_2.17    tools_4.2.1       stringr_1.4.1    \n[13] htmlwidgets_1.5.4 xfun_0.34         yaml_2.3.6        fastmap_1.1.0    \n[17] compiler_4.2.1    htmltools_0.5.3   knitr_1.40       \n\n\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\nrock_paper_scissors_outcome <- function(player1, player2){\n  ## Draw score\n  if(player1 == player2){\n    return(3)\n  }\n  ## p2 win conditions\n  else if(player1 == \"rock\" & player2 == \"paper\"){\n    return(6)\n  }else if(player1 == \"paper\" & player2 == \"scissors\"){\n    return(6)\n  }else if(player1 == \"scissors\" & player2 == \"rock\"){\n    return(6)\n  }\n  ## else lose\n  else{\n    return(0)\n  }\n}\n\n\n# testing the function\ntribble(~p1, ~p2,\n        \"rock\", \"rock\",\n        \"rock\", \"paper\",\n        \"scissors\", \"paper\") |>\n  mutate(\n    outcome = map2(\n      p1, \n      p2, \n      rock_paper_scissors_outcome\n      ) |>\n        simplify()\n    )\n\n# A tibble: 3 × 3\n  p1       p2    outcome\n  <chr>    <chr>   <dbl>\n1 rock     rock        3\n2 rock     paper       6\n3 scissors paper       0\n\n\nI’ll use a few different joins to map the first column and the second column to \"rock\", \"paper\" and \"scissors\", and also to map player 2’s move to a score.\n\np1_map <- \n  tribble(\n    ~X1, ~p1,\n    \"A\", \"rock\",\n    \"B\", \"paper\",\n    \"C\", \"scissors\"\n  )\n\np2_map <-\n  tribble(\n    ~X2, ~p2,\n    \"X\", \"rock\",\n    \"Y\", \"paper\",\n    \"Z\", \"scissors\"\n  )\n\nscore_map <-\n  tribble(\n    ~score, ~p2,\n    1, \"rock\",\n    2, \"paper\",\n    3, \"scissors\"\n  )\n\nReading in the data.\n\nstrategy <- read_delim(\n  \"2022-12-2_assets/input.txt\", \n  col_names = FALSE,\n  delim = \" \"\n  )\n\nRows: 2500 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \" \"\nchr (2): X1, X2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nIt’s just a few joins, then rowwise mapping of the rock_paper_scissors_outcome() function to get the score components. Adding the columns together and summarizing finishes it off.\n\nplay_score <- \n  strategy |>\n    left_join(p1_map) |>\n    left_join(p2_map) |>\n    left_join(score_map) |>\n    mutate(win = map2(\n        p1,\n        p2,\n        rock_paper_scissors_outcome\n      ) |>\n        simplify(),\n      total_score = score + win\n    )\n\nJoining, by = \"X1\"\nJoining, by = \"X2\"\nJoining, by = \"p2\"\n\n\n\nplay_score |>\n  summarise(total_score = sum(total_score))\n\n# A tibble: 1 × 1\n  total_score\n        <dbl>\n1       10624"
  }
]