[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Main",
    "section": "",
    "text": "I’ll be doing the Advent of Code 2022 here. I’ll probably be late most days. R+tidyverse is my preferred language, but might dip into some python as needed.\n\n\n\n\n\n\n\n\n  \n\n\n\n\nDay 1\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\n\n\n\n\n\n\n\n\n\nDec 1, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 2\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\n\n\n\n\n\n\n\n\n\nDec 2, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 3\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\nstringr\n\n\n\n\n\n\n\n\n\n\n\nDec 3, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 4\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\n\n\n\n\n\n\n\n\n\nDec 4, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDay 5\n\n\n\n\n\n\n\npython\n\n\n\n\n\n\n\n\n\n\n\nDec 5, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 6\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\npurrr\n\n\nmap\n\n\n\n\n\n\n\n\n\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 7\n\n\n\n\n\n\n\npython\n\n\ndefaultdict\n\n\npandas\n\n\n\n\n\n\n\n\n\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 8\n\n\n\n\n\n\n\nR\n\n\ntidyverse\n\n\n|>\n\n\napply\n\n\n\n\n\n\n\n\n\n\n\nDec 8, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\n  \n\n\n\n\nDay 9\n\n\n\n\n\n\n\nR\n\n\nlist()\n\n\n\n\n\n\n\n\n\n\n\nDec 9, 2022\n\n\nJosef Fruehwald\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "days/2022-12-9.html",
    "href": "days/2022-12-9.html",
    "title": "Day 9",
    "section": "",
    "text": "library(tidyverse)\nlibrary(ggdark)\nlibrary(khroma)\nlibrary(showtext)\nlibrary(scales)\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nfont_add(family = \"Noto Emoji\", regular = file.path(font_paths()[2], \"NotoEmoji-VariableFont_wght.ttf\"))\n\nshowtext_auto()\n\ntheme_set(dark_theme_gray() + \n            theme(title = element_text(family = \"christmas\", size = 20)))\n\nknitr::knit_hooks$set(crop = knitr::hook_pdfcrop)\n\n\nPart 1\nOk… step 1 I think is a function for calculating the distance between H and T.\n\nHead <- c(2,2)\nTail <- c(1,1)\nx <- (Head - Tail)^2\nmax(x)\n\n[1] 1\n\n\nOk, I think if \\(\\max((H-T)^2) <=1\\) then we don’t update, otherwise, update.\n\nmove_decision <- function(Head, Tail){\n  distance <- (Head-Tail) ^2\n  return(max(distance) > 1)\n}\n\n\nmove_decision(c(0,0), c(0,1))\n\n[1] FALSE\n\nmove_decision(c(0,0), c(1,0))\n\n[1] FALSE\n\nmove_decision(c(0,0), c(1,1))\n\n[1] FALSE\n\nmove_decision(c(0,0), c(0,2))\n\n[1] TRUE\n\nmove_decision(c(0,0), c(1,2))\n\n[1] TRUE\n\n\nNow, decide which way to move.\n\n## 1 Dim\nHead <- c(0,0)\nTail <- c(0,2)\nHead - Tail\n\n[1]  0 -2\n\n\nCan’t just do \\(\\frac{H-T}{2}\\) because of the diagonal case\n\n## 2 dim\nHead <- c(0,0)\nTail <- c(1,2)\nHead - Tail\n\n[1] -1 -2\n\n\nI think I can just use their sign though!\n\n## 1 dim\nHead <- c(0,0)\nTail <- c(0,2)\nsign(Head - Tail)\n\n[1]  0 -1\n\n## 2 dim\nHead <- c(0,0)\nTail <- c(1,2)\nsign(Head - Tail)\n\n[1] -1 -1\n\n\n\nmove_vector <- function(Head, Tail){\n  sign(Head-Tail)\n}\n\nOk, let’s load up the data and plan our history management.\n\nroute <- read_table(\"2022-12-9_assets/input.txt\", col_names = FALSE)\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  X1 = col_character(),\n  X2 = col_double()\n)\n\n\n\nroute |> head()\n\n# A tibble: 6 × 2\n  X1       X2\n  <chr> <dbl>\n1 U         1\n2 L         1\n3 D         2\n4 U         2\n5 R         2\n6 D         1\n\n\nI’ll make all steps explicit by multiplying out X1 by X2 times\n\nfull_route <- \n  route |>\n  mutate(all_steps = map2(X1, X2, ~tibble(step = rep(.x, .y)))) |>\n  select(all_steps) |>\n  unnest(cols = all_steps) |>\n  mutate(step_num = (1:n()) + 1)\n\nI think I’ll pre-compile an empty list to store head and tail states.\n\nHead_list <- vector(mode = \"list\", length = max(full_route$step_num))\nTail_list <- vector(mode = \"list\", length = max(full_route$step_num))\n\nInitial state\n\nHead_list[[1]] <- c(0,0)\nTail_list[[1]] <- c(0,0)\n\nNow, a function to return update move for the Head given U, D, L, R. I’ll make it a function but it could just be a named list\n\nHead_move <- function(dir){\n  move_list <- list(\n    U = c(0,1),\n    D = c(0,-1),\n    L = c(-1,0),\n    R = c(1,0)\n  )\n  return(move_list[[dir]])\n}\n\nNow, a function that takes:\n\nHead move direction\nstep number\nthe Head states\nthe Tail states\n\nAnd updates the Head and Tail states.\nOk, I hate this… but I’m going to use the global variables.\n\nHead_Tail_update <- function(dir, step){\n  Head_prev <- Head_list[[step-1]]\n  Tail_prev <- Tail_list[[step-1]]\n  head_movement <- Head_move(dir)\n  \n  Head_now <- Head_prev + head_movement\n  if(move_decision(Head_now, Tail_prev)){\n    tail_movement <- move_vector(Head_now, Tail_prev)\n    Tail_now <- Tail_prev + tail_movement\n  } else {\n    Tail_now <- Tail_prev\n  }\n  Head_list[[step]] <<- Head_now\n  Tail_list[[step]] <<- Tail_now\n  return()\n}\n\n\nx <- map2(full_route$step, full_route$step_num, Head_Tail_update)\n\n\ntail_pos_df <- \n  Tail_list |>\n  reduce(rbind) |> \n  data.frame() |>\n  mutate(part = \"tail\",\n         step = 1:n())\n\nhead_pos_df <-\n  Head_list |>\n  reduce(rbind) |> \n  data.frame() |>\n  mutate(part = \"head\",\n         step = 1:n())\n\n\nall_pos <- bind_rows(tail_pos_df, head_pos_df)\n\n\nall_pos |>\n  ggplot(aes(X1, X2, color = step)) +\n    geom_path(linewidth = 1) +\n    coord_fixed()+\n    scale_color_hawaii()+\n    labs(x = \"x\",\n         y = \"y\",\n         title = \"path of head and tail\")+\n    facet_wrap(~part)\n\n\n\n\nFigure 1: Paths of head and tail\n\n\n\n\n\n\nPart 2\nOk, I think I can keep a lot of my functions the same, just the Tail state is now a list of 9 vectors, and every head movement involves updating the tail state 9 times.\n\nHead_list <- rep(list(c(0,0)), max(full_route$step_num))\nTail_list <- map(1:max(full_route$step_num), ~rep(list(c(0,0)), 9))\n\n\nHead_Tail_update2 <- function(dir, step){\n  Head_prev <- Head_list[[step-1]]\n\n  head_movement <- Head_move(dir)\n  \n  Head_now <- Head_prev + head_movement\n  Head_list[[step]] <<- Head_now\n\n  reference <- Head_now\n  \n  for(i in 1:9){\n    Tail_prev <- Tail_list[[step-1]][[i]]\n    if(move_decision(reference, Tail_prev)){\n      tail_movement <- move_vector(reference, Tail_prev)\n      Tail_now <- Tail_prev + tail_movement\n    } else {\n      Tail_now <- Tail_prev\n    }\n    reference <- Tail_now\n    Tail_list[[step]][[i]] <<- Tail_now\n  }\n  return()\n}\n\n\nx <- map2(full_route$step, full_route$step_num, Head_Tail_update2)\n\n\nmap(Tail_list, ~.x[[9]]) |>\n  reduce(rbind) |>\n  data.frame() |>\n  unique() |>\n  nrow()\n\n[1] 2458\n\n\n\ntail_pos_df <- \n  map(Tail_list, ~.x[[9]]) |>\n  reduce(rbind) |>\n  data.frame() |>\n  mutate(part = \"tail\",\n         step = 1:n())  \n\n## head_pos_df the same\n\nall_pos <- bind_rows(tail_pos_df, head_pos_df)\n\n\nall_pos |>\n  ggplot(aes(X1, X2, color = step)) +\n    geom_path(linewidth = 1) +\n    coord_fixed()+\n    scale_color_hawaii()+\n    labs(x = \"x\",\n         y = \"y\",\n         title = \"path of head and tail\")+\n    facet_wrap(~part)\n\n\n\n\nFigure 2: Paths of head and tail"
  },
  {
    "objectID": "days/2022-12-8.html",
    "href": "days/2022-12-8.html",
    "title": "Day 8",
    "section": "",
    "text": "Part 1\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(rlang)\n\n\nAttaching package: 'rlang'\n\nThe following objects are masked from 'package:purrr':\n\n    %@%, as_function, flatten, flatten_chr, flatten_dbl, flatten_int,\n    flatten_lgl, flatten_raw, invoke, splice\n\nlibrary(ggdark)\nlibrary(khroma)\nlibrary(showtext)\n\nLoading required package: sysfonts\nLoading required package: showtextdb\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nlibrary(ggforce)\nlibrary(emojifont)\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nfont_add(family = \"Noto Emoji\", regular = file.path(font_paths()[2], \"NotoEmoji-VariableFont_wght.ttf\"))\n\nshowtext_auto()\n\ntheme_set(theme_no_axes(base.theme = dark_theme_gray()) + \n            theme(title = element_text(family = \"christmas\", size = 20)))\n\nInverted geom defaults of fill and color/colour.\nTo change them back, use invert_geom_defaults().\n\nknitr::knit_hooks$set(crop = knitr::hook_pdfcrop)\n\n\ntrees <- read_table(\"2022-12-8_assets/input.txt\", col_names = F)\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  X1 = col_character()\n)\n\n\n\ntrees |>\n  pull(X1)|>\n  map(~str_split(.x, pattern = \"\", simplify = T)) |>\n  map(as.numeric) |>\n  reduce(rbind) -> tree_mat\nrownames(tree_mat) <- NULL\n\n\ntree_mat |>\n  data.frame() |>\n  mutate(y = 1:n()) |>\n  pivot_longer(-y, names_to = \"x\") |>\n  mutate(x = str_remove(x, \"X\") |> as.numeric()) |>\n  ggplot(aes(x, y, fill = value))+\n    geom_raster() +\n    scale_y_reverse(expand = expansion(mult = 0))+\n    scale_x_continuous(expand = expansion(mult = 0))+\n    scale_fill_bamako(reverse = FALSE)+\n    labs(fill = \"height\")+\n    coord_fixed()\n\n\n\n\nFigure 1: Tree Height Map\n\n\n\n\nI think if I was cleverer I could use some kind of convolution…\n\ngrad_max <- function(x, dir = 1){\n  if(dir == 1){\n    map(1:length(x), ~max(x[1:.x])) |>\n      simplify() -> out\n  }else{\n    map(1:length(x), ~max(x[.x:length(x)])) |>\n      simplify() -> out\n  }\n  return(out)\n}\n\nrev_diff <- function(x){\n  out <- x |> rev() |> diff() |> rev()\n  return(out)\n}\n\n\nl_to_r <- apply(tree_mat, 1, grad_max) |> t()\nr_to_l <- apply(tree_mat, 1, grad_max, dir = -1) |> t()\nt_to_b <- apply(tree_mat, 2, grad_max)\nb_to_t <- apply(tree_mat, 2, grad_max, dir = -1)\n\nOk, I spend a lot of time over thinking this. The visible trees are visible wherever this increasing max goes up. I’ll work that out for all 4 matrices (1 where visible, 0 otherwise) and just add them together. Any location >0 will be visible.\n\nlr_vis <- apply(l_to_r, 1, diff) |> t()\nlr_vis <- (lr_vis > 0)*1\nlr_vis <- cbind(rep(1, 99), lr_vis)\n\n\nrl_vis <- apply(r_to_l, 1, rev_diff) |> t()\nrl_vis <- (rl_vis > 0)*1\nrl_vis <- cbind(rl_vis, rep(1, 99))\n\n\ntb_vis <- apply(t_to_b, 2, diff)\ntb_vis <- (tb_vis > 0)*1\ntb_vis <- rbind(rep(1, 99), tb_vis)\n\n\nbt_vis <- apply(b_to_t, 2, rev_diff)\nbt_vis <- (bt_vis > 0)*1\nbt_vis <- rbind(bt_vis, rep(1, 99))\n\n\nall_viz = lr_vis + rl_vis + bt_vis + tb_vis\n\n\nall_viz |>\n  data.frame() |>\n  mutate(y = 1:n()) |>\n  pivot_longer(-y, names_to = \"x\") |>\n  mutate(x = str_remove(x, \"X\") |> as.numeric()) |>\n  ggplot(aes(x, y, fill = value))+\n    geom_raster() +\n    scale_y_reverse(expand = expansion(mult = 0))+\n    scale_x_continuous(expand = expansion(mult = 0))+\n    scale_fill_bamako()+\n    coord_fixed()\n\n\n\n\n\nsum(all_viz > 0)\n\n[1] 1801\n\n\n\n\nPart 2\n\nview_line_score <- function(x){\n  score <- which((x - x[1])[-1] >= 0)[1]\n  if(is.na(score)){\n    return(length(x)-1)\n  }else{\n    return(score)\n  }\n}\nscorer <- function(x, y, mat){\n  view_line <- list(\n    north = rev(mat[1:(x),y]),\n    east = mat[x, (y):ncol(mat)],\n    south = mat[x:nrow(mat), y],\n    west = rev(mat[x, 1:y])\n  )\n  \n  score <- \n  view_line |>\n    map(view_line_score) |>\n    reduce(`*`)\n\n  return(score)\n}\n\n\nscorer(2,2, tree_mat)\n\n[1] 4\n\n\n\nexpand_grid(\n  x = 2:98,\n  y = 2:98\n) |>\n  mutate(view_score = map2(x, y, ~scorer(.x, .y, tree_mat)) |> simplify()) -> view_scores\n\n\nview_scores |>\n  arrange(desc(view_score)) |>\n  slice(1) -> winner\nwinner\n\n# A tibble: 1 × 3\n      x     y view_score\n  <int> <int>      <dbl>\n1    54    23     209880\n\n\n\nview_scores |>\n  ggplot(aes(x, y, fill = view_score))+\n    geom_raster()+\n    geom_text(data = winner, \n                 label = emoji(\"evergreen_tree\"),\n                 family = \"Noto Emoji\",\n                 size = 10)+\n    scale_fill_bamako(trans = \"log10\")+\n    scale_y_reverse(expand = expansion(mult = 0))+\n    scale_x_continuous(expand = expansion(mult = 0))+\n    coord_fixed()  \n\n\n\n\nFigure 2: Location of winning treehouse tree"
  },
  {
    "objectID": "days/2022-12-6.html",
    "href": "days/2022-12-6.html",
    "title": "Day 6",
    "section": "",
    "text": "Part 1\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\nx <- read_lines(\"2022-12-6_assets/input.txt\")\n\n\ninput <- tibble(signal = str_split(x, pattern = \"\")[[1]])\n\n\ninput_lagged <- \n  input |>\n  mutate(lag1 = lag(signal, 1),\n         lag2 = lag(signal, 2),\n         lag3 = lag(signal, 3),\n         n = 1:n())\n\n\ninput_lagged |>\n  drop_na() |>\n  mutate(sequence = str_c(signal, lag1, lag2, lag3),\n         len_unique_sequence = map(sequence, ~.x |> \n                                     str_split(\"\") |>\n                                     simplify() |>\n                                     unique() |>\n                                     length()) |> simplify()) |> \n  filter(len_unique_sequence == 4) |>\n  slice(1) |>\n  pull(n)\n\n[1] 1300\n\n\n\n\nPart 2\nI’ve seen the folly of my ways.\n\nchunkup <- function(chunk_size, x){\n  start_indices = seq(1,length(x)-chunk_size+1)\n  end_indicies = seq(chunk_size, length(x))\n  pad <- rep(NA, chunk_size - 1)\n  out <- map2(start_indices, end_indicies, ~x[..1:..2])\n  out <- c(pad, out)\n  return(out)\n}\n\nReplicating part 1 just to check\n\ninput |>\n  mutate(\n    id = 1:n(),\n    sequences = chunkup(4, signal),\n    seq_unique_len = map(\n      sequences, ~.x |> \n        unique() |>  \n        length()\n    ) |> \n      simplify()\n  ) |>\n  filter(seq_unique_len == 4)\n\n# A tibble: 1,903 × 4\n   signal    id sequences seq_unique_len\n   <chr>  <int> <list>             <int>\n 1 w       1300 <chr [4]>              4\n 2 g       1301 <chr [4]>              4\n 3 v       1302 <chr [4]>              4\n 4 z       1303 <chr [4]>              4\n 5 t       1304 <chr [4]>              4\n 6 w       1305 <chr [4]>              4\n 7 p       1309 <chr [4]>              4\n 8 z       1310 <chr [4]>              4\n 9 h       1311 <chr [4]>              4\n10 p       1316 <chr [4]>              4\n# … with 1,893 more rows\n\n\nLooks good!\n\ninput |>\n  mutate(\n    id = 1:n(),\n    sequences = chunkup(14, signal),\n    seq_unique_len = map(\n      sequences, ~.x |> \n        unique() |>  \n        length()\n    ) |> \n      simplify()\n  ) |>\n  filter(seq_unique_len == 14) |>\n  slice(1) |>\n  pull(id)\n\n[1] 3986\n\n\n\n\nJust for Fun\n\nlibrary(ggdark)\nlibrary(khroma)\nlibrary(showtext)\n\nLoading required package: sysfonts\n\n\nLoading required package: showtextdb\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nlibrary(emojifont)\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nfont_add(family = \"Noto Emoji\", regular = file.path(font_paths()[2], \"NotoEmoji-VariableFont_wght.ttf\"))\nshowtext_auto()\n\ntheme_set(dark_theme_gray() + \n            theme(title = element_text(family = \"christmas\", size = 20)))\n\nInverted geom defaults of fill and color/colour.\nTo change them back, use invert_geom_defaults().\n\n\n\ninput |>\n  mutate(\n    id = 1:n(),\n    sequences = chunkup(14, signal),\n    seq_unique_len = map(\n      sequences, ~.x |> \n        unique() |>  \n        length()\n    ) |> \n      simplify()\n  ) |>\n  slice(14:n()) |>\n  ggplot(aes(id, seq_unique_len))+\n    geom_point(position = position_jitter(width = 0, height = 0.1))\n\n\n\n\nFigure 1: the unique length of 14 character long strings\n\n\n\n\n\nsequence_checker <- function(seq_len, df){\n  df |>\n    mutate(\n      id = 1:n(),\n      sequences = chunkup(seq_len, signal),\n      !!quo_name(seq_len) := map(\n        sequences, ~.x |> \n          unique() |>  \n          length()\n      ) |> \n        simplify()\n    ) |>\n    slice(seq_len:n()) |>\n    select(id, !!quo_name(seq_len)) -> out\n  return(out)\n}\n\n\nmap(4:26, ~sequence_checker(.x, input)) |>\n  reduce(left_join) |>\n  pivot_longer(-1, names_to = \"seq_len\", values_to = \"unique_len\") |>\n  drop_na() |>\n  mutate(prop_unique = unique_len/as.numeric(seq_len)) -> unique_df\n\n\nunique_df |>\n  mutate(seq_len = as.numeric(seq_len)) |>\n  filter(seq_len == unique_len) |>\n  group_by(seq_len) |>\n  slice(1) |>\n  ggplot(aes(seq_len, id))+\n    geom_text(label = emoji(\"snowflake\"), \n              size = 12, \n              family = \"Noto Emoji\")+\n    labs(x = \"sequence length\",\n         y = \"position of first unique sequence\")\n\n\n\n\nFigure 2: Location of first sequence n long\n\n\n\n\nLooks like no sequence longer than 14 has a unique run of letters!\n\nunique_df |>\n  ggplot(aes(id, prop_unique))+\n  stat_smooth(aes(group = seq_len, color = as.numeric(seq_len)))+\n  scale_color_bam(name = \"sequence\\nlength\", midpoint = median(4:26))+\n  scale_x_continuous(labels = label_comma())+\n  ylim(0,1)\n\n\n\n\nFigure 3: Number of unique characters divided by sequence length"
  },
  {
    "objectID": "days/2022-12-7.html",
    "href": "days/2022-12-7.html",
    "title": "Day 7",
    "section": "",
    "text": "Part 1\nI think I’ll use python, specifically collections.defaultdict().\n\nfrom path_dict import PathDict\nfrom collections import defaultdict\nimport re\nimport pandas as pd\n\n\ndef default0():\n  return 0\n\n\nfilesystem = PathDict({})\ndir_sum = defaultdict(default0)\n\n\nwith open(\"2022-12-7_assets/input.txt\", 'r') as f:\n  history = f.readlines()\nhistory = [line.strip().split() for line in history]\n\n\ndef path_update(path, x):\n  if x == \"/\":\n    path = [\"/\"]\n  elif x == \"..\":\n    _ = path.pop(-1)\n  else:\n    path += [x]\n  return(path)\n\nI think I can skip over trying to build out the directory structure in the PathDict … but will I regret it in part 2\n\npath_state = [\"/\"]\nscanned_files = []\n\nfor line in history:\n  if line[0] == \"$\":\n    if line[1] == \"cd\":\n      path_state = path_update(path_state, line[2])\n  else:\n    if re.search(r'\\d', line[0]):\n      # this point messed me up at first! \n      # There are (obviously?) not unique individual filenames!\n      file_name = \"/\".join(path_state) + f\"/line[1]\"\n      if not file_name in scanned_files:\n        # *and* there's not unique path names!\n        for idx in range(len(path_state)):\n          path_name = \"/\".join(path_state[0:idx+1])\n          dir_sum[path_name] += int(line[0])\n        scanned_files.append(path_state+[line[1]])\n\n\ndir_df = pd.DataFrame(dir_sum, index = [1])\n\nI kind of badly want to pivot over to R via reticulate, but let’s try pandas real quick.\n\nlong_dir = pd.melt(dir_df)\nlong_dir[long_dir[\"value\"] <= 100_000][\"value\"].sum()\n\n1390824\n\n\n\nlong_dir\n\n                       variable     value\n0                             /  46728267\n1                         //cvt  32283214\n2                //cvt/bbgsthsd    455345\n3                //cvt/chhdjtlw   1351375\n4       //cvt/chhdjtlw/mbdrgfzs    164331\n..                          ...       ...\n164            //zft/zrtm/djfww     30770\n165            //zft/zrtm/vhdhn   1481975\n166      //zft/zrtm/vhdhn/djfww    961278\n167  //zft/zrtm/vhdhn/djfww/zft    100941\n168        //zft/zrtm/vhdhn/gqc    156273\n\n[169 rows x 2 columns]\n\n\n\n\nPart 2\n\ntotal_space = 70_000_000\nneeded_space = 30_000_000\navailable_space = total_space - dir_sum[\"/\"]\nmin_size = needed_space - available_space\n\n\nlong_dir[\"diff_from_needed\"] = long_dir[\"value\"] - min_size\n(long_dir[\n  long_dir[\"diff_from_needed\"] > 0\n  ]\n  .sort_values(by = \"diff_from_needed\")\n  .iloc[0]\n  [\"value\"]\n)\n\n7490863\n\n\n\n\nJust for fun\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(reticulate)\nlibrary(ggdark)\nlibrary(khroma)\nlibrary(showtext)\n\nLoading required package: sysfonts\nLoading required package: showtextdb\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nlibrary(ggbeeswarm)\nlibrary(emojifont)\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nfont_add(family = \"Noto Emoji\", regular = file.path(font_paths()[2], \"NotoEmoji-VariableFont_wght.ttf\"))\n\nshowtext_auto()\n\ntheme_set(dark_theme_gray() + \n            theme(title = element_text(family = \"christmas\", size = 20)))\n\nInverted geom defaults of fill and color/colour.\nTo change them back, use invert_geom_defaults().\n\n\n\nlong_dir = py$dir_df\n\n\npy$long_dir |>\n  mutate(depth = str_count(variable, \"/\") - 1) |>\n  ggplot(aes(factor(depth), value, color = value))+\n    #geom_quasirandom(varwidth = TRUE, width = 0.2)+\n    geom_beeswarm()+\n    stat_summary(fun = median, \n                 geom = \"text\", \n                 color = \"white\",\n                 label = emoji(\"floppy_disk\"),\n                 family = \"Noto Emoji\",\n                 size = 6)+\n    scale_color_hawaii(trans = \"log10\", guide = \"none\")+\n    labs(x = \"embedding depth\",\n         y = \"directory size (log scale)\",\n         title = \"Embedding vs Size\")+\n    scale_y_log10(labels = label_comma())+\n    annotation_logticks(color = \"white\", sides = 'l')\n\n\n\n\nFigure 1: Directory embedding depth and total size"
  },
  {
    "objectID": "days/2022-12-5.html",
    "href": "days/2022-12-5.html",
    "title": "Day 5",
    "section": "",
    "text": "I think for preprocessing the text, I’m going to start off with python.\n\n```{r}\nlibrary(reticulate)\n```\n\n\n```{python}\nwith open(\"2022-12-5_assets/input.txt\", \"r\") as data:\n  lines = data.readlines()\n```\n\n\n\n\n```{python}\ninitial_state = [x.replace(\"\\n\", \"\") \n                  for x in lines \n                    if \"move\" not in x and len(x) > 1]\ninitial_state\n```\n\n['[N]     [C]                 [Q]    ', '[W]     [J] [L]             [J] [V]', '[F]     [N] [D]     [L]     [S] [W]', '[R] [S] [F] [G]     [R]     [V] [Z]', '[Z] [G] [Q] [C]     [W] [C] [F] [G]', '[S] [Q] [V] [P] [S] [F] [D] [R] [S]', '[M] [P] [R] [Z] [P] [D] [N] [N] [M]', '[D] [W] [W] [F] [T] [H] [Z] [W] [R]', ' 1   2   3   4   5   6   7   8   9 ']\n\n\nThere’s not a fixed delimiter between every column. Each column is 3 characters wide, with a space in between.\n\n```{python}\n[len(x) for x in initial_state]\n```\n\n[35, 35, 35, 35, 35, 35, 35, 35, 35]\n\n\n\n```{python}\ndef three_split(x):\n  out = []\n  start = 0\n  done = False\n  while not done:\n    end = start + 3\n    item = x[start:end].strip()\n    out.append(item)\n    start = end + 1\n    if start > len(x):\n      done = True\n  return(out)\n```\n\n\n```{python}\nstate_rows = [three_split(x) for x in initial_state]\nstate_rows\n```\n\n[['[N]', '', '[C]', '', '', '', '', '[Q]', ''], ['[W]', '', '[J]', '[L]', '', '', '', '[J]', '[V]'], ['[F]', '', '[N]', '[D]', '', '[L]', '', '[S]', '[W]'], ['[R]', '[S]', '[F]', '[G]', '', '[R]', '', '[V]', '[Z]'], ['[Z]', '[G]', '[Q]', '[C]', '', '[W]', '[C]', '[F]', '[G]'], ['[S]', '[Q]', '[V]', '[P]', '[S]', '[F]', '[D]', '[R]', '[S]'], ['[M]', '[P]', '[R]', '[Z]', '[P]', '[D]', '[N]', '[N]', '[M]'], ['[D]', '[W]', '[W]', '[F]', '[T]', '[H]', '[Z]', '[W]', '[R]'], ['1', '2', '3', '4', '5', '6', '7', '8', '9']]\n\n\nI had a big hang up here, because I created the list of empty lists with [[]] * 9, which copies the empty list, so when I appended a value to columns[0], it appended that value to all columns.\n\n```{python}\ncolumns = [[] for _ in range(len(state_rows[0]))]\nfor ridx, row in enumerate(state_rows):\n  for cidx, col in enumerate(state_rows[ridx]):\n    if len(col) > 0 :\n      columns[cidx].append(col)\n    \nprint(columns)\n```\n\n[['[N]', '[W]', '[F]', '[R]', '[Z]', '[S]', '[M]', '[D]', '1'], ['[S]', '[G]', '[Q]', '[P]', '[W]', '2'], ['[C]', '[J]', '[N]', '[F]', '[Q]', '[V]', '[R]', '[W]', '3'], ['[L]', '[D]', '[G]', '[C]', '[P]', '[Z]', '[F]', '4'], ['[S]', '[P]', '[T]', '5'], ['[L]', '[R]', '[W]', '[F]', '[D]', '[H]', '6'], ['[C]', '[D]', '[N]', '[Z]', '7'], ['[Q]', '[J]', '[S]', '[V]', '[F]', '[R]', '[N]', '[W]', '8'], ['[V]', '[W]', '[Z]', '[G]', '[S]', '[M]', '[R]', '9']]\n\n\n\n\n\n\n```{python}\nmove_instructions = [x.strip() for x in lines if \"move\" in x]\n```\n\n\n```{python}\nimport re\nmove_list = [re.findall(r'\\d+', line) \n              for line in move_instructions]\nmove_int = [[int(x[0]), int(x[1])-1, int(x[2])-1] \n              for x in move_list]\n```\n\n\n```{python}\ndef move_fun(m):\n  n = m[0]\n  fro = move[1]\n  to = move[2]\n  for i in range(n):\n    columns[to].insert(0, columns[fro].pop(0))\n```\n\n\n```{python}\nfor move in move_int:\n  move_fun(move)\n```\n\n\n```{python}\n\"\".join([x[0].replace(\"[\", \"\").replace(\"]\", \"\") for x in columns])\n```\n\n'FWNSHLDNZ'"
  },
  {
    "objectID": "days/2022-12-4.html",
    "href": "days/2022-12-4.html",
    "title": "Day 4",
    "section": "",
    "text": "Part 1\nGiven two ranges of numbers, we need to find how many ranges have a complete overlap.\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\ndata <- read_csv(\"2022-12-4_assets/input.txt\", col_names = FALSE)\n\nRows: 1000 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): X1, X2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\nelf_ranges <- \n  data |>\n  separate(\n    X1, \n    into = c(\"elf1_start\", \"elf1_end\"),\n    convert = TRUE\n  ) |>\n  separate(\n    X2,\n    into = c(\"elf2_start\", \"elf2_end\"),\n    convert = TRUE\n  )\n\nFor two ranges of numbers, they overlap if\nx1   .....   x2\n   y1  .......  y2\n   \nx1 <= y2\ny1 <= x2\n\noverlaps <- \n  elf_ranges |>\n  filter(elf1_start <= elf2_end,\n         elf2_start <= elf1_end)\n\nI think I have to use disjunction to find complete containment? Either\nx1 .......... x2\n   y1 ... y2\n   \nx1 <= y1 & x2 >= y2 || y1 <= x1 & y2 >= x2\n\noverlaps |>\n  filter((elf1_start <= elf2_start & elf1_end >= elf2_end) | \n           (elf2_start <= elf1_start & elf2_end >= elf1_end)) |>\n  nrow()\n\n[1] 441\n\n\n\n\nPart 2\nHah! Got the number of overlaps first!\n\noverlaps |> nrow()\n\n[1] 861\n\n\n\n\nJust for Fun\n\nlibrary(showtext)\n\nLoading required package: sysfonts\n\n\nLoading required package: showtextdb\n\nlibrary(ggdark)\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nlibrary(khroma)\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nshowtext_auto()\n\ntheme_set(dark_theme_gray() + \n            theme(title = element_text(family = \"christmas\", size = 20)))\n\nInverted geom defaults of fill and color/colour.\nTo change them back, use invert_geom_defaults().\n\n\n\noverlaps |>\n  rowwise() |>\n  mutate(overlap_start = max(c(elf1_start, elf2_start)),\n         overlap_end = min(c(elf1_end, elf2_end)),\n         overlap_df = map2(overlap_start, overlap_end, ~tibble(position = .x:.y))) |>\n  select(overlap_df) |>\n  unnest(overlap_df) |>\n  ggplot(aes(position))+\n    stat_bin(binwidth = 1,\n             aes(y = after_stat(count), \n                 fill = after_stat(count))) +\n    stat_density(aes(y = after_stat(count),\n                     linewidth = after_stat(count)), \n                 geom = \"path\")+\n    scale_fill_oslo(guide = \"none\")+\n    scale_linewidth(guide = \"none\")+\n    labs(title = \"overlap by position\")\n\n\n\n\nFigure 1: Degree of overlap by position"
  },
  {
    "objectID": "days/2022-12-1.html",
    "href": "days/2022-12-1.html",
    "title": "Day 1",
    "section": "",
    "text": "Source: https://adventofcode.com/2022/day/1"
  },
  {
    "objectID": "days/2022-12-1.html#puzzle-text",
    "href": "days/2022-12-1.html#puzzle-text",
    "title": "Day 1",
    "section": "Puzzle Text",
    "text": "Puzzle Text\n\n--- Day 1: Calorie Counting ---\nSanta’s reindeer […]\nThe Elves take turns writing down the number of Calories contained by the various meals, snacks, rations, etc. that they’ve brought with them, one item per line. Each Elf separates their own inventory from the previous Elf’s inventory (if any) by a blank line.\nFor example, suppose the Elves finish writing their items’ Calories and end up with the following list:\n1000 \n2000 \n3000\n\n4000\n\n5000 \n6000\n\n7000 \n8000 \n9000\n\n10000\nThis list represents the Calories of the food carried by five Elves:\n\n\n\nThe first Elf is carrying food with 1000, 2000, and 3000 Calories, a total of 6000 Calories.\n\n\n\nThe second Elf is carrying one food item with 4000 Calories.\n\n\n\nThe third Elf is carrying food with 5000 and 6000 Calories, a total of 11000 Calories.\nThe fourth Elf is carrying food with 7000, 8000, and 9000 Calories, a total of 24000 Calories.\nThe fifth Elf is carrying one food item with 10000 Calories.\n\nIn case the Elves get hungry and need extra snacks, they need to know which Elf to ask: they’d like to know how many Calories are being carried by the Elf carrying the most Calories. In the example above, this is 24000 (carried by the fourth Elf).\nFind the Elf carrying the most Calories. How many total Calories is that Elf carrying?"
  },
  {
    "objectID": "days/2022-12-1.html#r-session-info",
    "href": "days/2022-12-1.html#r-session-info",
    "title": "Day 1",
    "section": "R Session Info",
    "text": "R Session Info\n\nsessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.30     jsonlite_1.8.3    magrittr_2.0.3    evaluate_0.17    \n [5] rlang_1.0.6       stringi_1.7.8     cli_3.4.1         renv_0.15.5      \n [9] rstudioapi_0.14   rmarkdown_2.17    tools_4.2.1       stringr_1.4.1    \n[13] htmlwidgets_1.5.4 xfun_0.34         yaml_2.3.6        fastmap_1.1.0    \n[17] compiler_4.2.1    htmltools_0.5.3   knitr_1.40       \n\n\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nlibrary(knitr)\nlibrary(kableExtra)\n\n\nAttaching package: 'kableExtra'\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows"
  },
  {
    "objectID": "days/2022-12-1.html#loading-data",
    "href": "days/2022-12-1.html#loading-data",
    "title": "Day 1",
    "section": "Loading Data",
    "text": "Loading Data\nFirst attempts at read_csv() were problematic because blank lines were ignored. skip_empty_rows = TRUE by default.\n\ncalories <- \n  read_csv(\n    \"2022-12-1_assets/input.txt\", \n    col_names = FALSE,\n    skip_empty_rows = FALSE\n    )\n\nRows: 2223 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (1): X1\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nDouble checking there are enough NAs.\n\ncalories |>\n  count(is.na(X1)) |>\n  kbl() |>\n  kable_styling(full_width = FALSE)\n\n\n\n \n  \n    is.na(X1) \n    n \n  \n \n\n  \n    FALSE \n    2000 \n  \n  \n    TRUE \n    223"
  },
  {
    "objectID": "days/2022-12-1.html#strategy",
    "href": "days/2022-12-1.html#strategy",
    "title": "Day 1",
    "section": "Strategy",
    "text": "Strategy\nI’ll identify the rows with NA and fill them with the row index. Then fill downward. I’ll need a special rule for the first row.\n\ncalories |>\n  ## a unique id for each elf.\n  ## won't increment by 1, but will be unique\n  mutate(\n    row_idx = 1:n(),\n    elf_id = case_when(\n      is.na(X1) ~ row_idx,  \n      row_idx == 1 ~ row_idx\n    )\n  ) |>\n  ## fill in the elf id for all rows\n  fill(elf_id) |>\n  ## drop na values for summarising\n  drop_na() |>\n  ## group_by, summarise, arrange\n  group_by(elf_id) |>\n  summarise(total_calories = sum(X1)) |>\n  arrange(desc(total_calories)) |>\n  ## pull the top number \n  slice(1) |>\n  pull(total_calories)\n\n[1] 70764"
  },
  {
    "objectID": "days/2022-12-1.html#just-for-fun",
    "href": "days/2022-12-1.html#just-for-fun",
    "title": "Day 1",
    "section": "Just for fun",
    "text": "Just for fun\n\nlibrary(showtext)\n\nLoading required package: sysfonts\n\n\nLoading required package: showtextdb\n\nlibrary(ggdark)\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nlibrary(khroma)\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nshowtext_auto()\n\n\ntotal_calories <- \n  calories |>\n    ## a unique id for each elf.\n    ## won't increment by 1, but will be unique\n    mutate(\n      row_idx = 1:n(),\n      elf_id = case_when(\n        is.na(X1) ~ row_idx,  \n        row_idx == 1 ~ row_idx\n      )\n    ) |>\n    ## fill in the elf id for all rows\n    fill(elf_id) |>\n    ## drop na values for summarising\n    drop_na() |>\n    ## group_by, summarise, arrange\n    group_by(elf_id) |>\n    summarise(total_calories = sum(X1)) |>\n    arrange(desc(total_calories)) |>\n    mutate(rank = 1:n())\n\n\ntotal_calories |>\n  ggplot(aes(rank, total_calories)) + \n    geom_point()+\n    scale_x_continuous(labels = label_comma())+\n    scale_y_continuous(labels = label_comma())+\n    labs(title = \"Total calories per elf\")+\n    dark_theme_gray()+\n    theme(title = element_text(family = \"christmas\", size = 20))\n\n\n\n\nFigure 1: total calories by rank\n\n\n\n\n\ntotal_calories |>\n  arrange(elf_id) |>\n  mutate(elf_order = 1:n()) |>\n  ggplot(aes(elf_order, total_calories, color = rank)) + \n    geom_point()+\n    scale_x_continuous(labels = label_comma())+\n    scale_y_continuous(labels = label_comma())+\n    scale_color_oslo(reverse = TRUE) +\n    guides(colour = guide_colourbar(reverse = TRUE))+\n    labs(title = \"Total calories per elf\")+\n    dark_theme_gray()+\n    theme(title = element_text(family = \"christmas\", size = 20))\n\n\n\n\nFigure 2: total calories by order"
  },
  {
    "objectID": "days/2022-12-3.html",
    "href": "days/2022-12-3.html",
    "title": "Day 3",
    "section": "",
    "text": "Source: https://adventofcode.com/2022/day/3"
  },
  {
    "objectID": "days/2022-12-3.html#description",
    "href": "days/2022-12-3.html#description",
    "title": "Day 3",
    "section": "Description:",
    "text": "Description:\nGiven a string of letters, we need to split them in half, and then find the single letter in common between them. Each letter is assigned a score, and then we need to sum them up.\nI think I’ll rely on stringr for this?\n\nsessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.30     jsonlite_1.8.3    magrittr_2.0.3    evaluate_0.17    \n [5] rlang_1.0.6       stringi_1.7.8     cli_3.4.1         renv_0.15.5      \n [9] rstudioapi_0.14   rmarkdown_2.17    tools_4.2.1       stringr_1.4.1    \n[13] htmlwidgets_1.5.4 xfun_0.34         yaml_2.3.6        fastmap_1.1.0    \n[17] compiler_4.2.1    htmltools_0.5.3   knitr_1.40       \n\n\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\ninput <- read_tsv(\n  \"2022-12-3_assets/input.txt\", \n  col_names = FALSE\n)\n\nRows: 300 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (1): X1\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\ncompartment <- \n  input |>\n  mutate(\n    # Get a total character count\n    n = nchar(X1),\n    # split the whole character string into a list\n    item_list = map(X1, ~str_split(.x, pattern = \"\", simplify = TRUE)),\n    # get the vector for the first half\n    compartment1 = map2(item_list, n, ~.x[1:(.y/2)]),\n    # get the vector for the second half\n    compartment2 = map2(item_list, n, ~.x[((.y/2)+1):.y]),\n    # get the shared values\n    shared = map2(compartment1, compartment2, ~.x[.x %in% .y])\n  ) \n\nAt this point, there are some values in shared are longer than 1. I need to check on those\n\ncompartment |>\n  mutate(n_shared = map(shared, length) |> simplify()) |>\n  filter(n_shared > 1) |>\n  sample_n(size = 5) |>\n  pull(shared)\n\n[[1]]\n[1] \"R\" \"R\"\n\n[[2]]\n[1] \"V\" \"V\"\n\n[[3]]\n[1] \"z\" \"z\"\n\n[[4]]\n[1] \"n\" \"n\"\n\n[[5]]\n[1] \"w\" \"w\" \"w\"\n\n\nI see, they’re repeated. I’ll uniquify and see if it’s all just length 1\n\ncompartment |>\n  mutate(unique_shared = map(shared, unique),\n         n_unique = map(unique_shared, length) |> simplify()) |>\n  filter(n_unique !=  1)\n\n# A tibble: 0 × 8\n# … with 8 variables: X1 <chr>, n <int>, item_list <list>, compartment1 <list>,\n#   compartment2 <list>, shared <list>, unique_shared <list>, n_unique <int>\n\n\nOk, good to go.\n\nshared_item_df <- \n  compartment |>\n  mutate(unique_shared = map(shared, unique) |> simplify()) \n\nI’ll use named vectors again to get the scores.\n\nitem_score = (1:52) |> set_names(c(letters, LETTERS))\n\n\nshared_item_df |>\n  mutate(priority = item_score[unique_shared]) |>\n  summarise(priority = sum(priority))\n\n# A tibble: 1 × 1\n  priority\n     <int>\n1     7763"
  },
  {
    "objectID": "days/2022-12-3.html#just-for-fun",
    "href": "days/2022-12-3.html#just-for-fun",
    "title": "Day 3",
    "section": "Just for fun",
    "text": "Just for fun\n\nlibrary(ggdark)\nlibrary(khroma)\nlibrary(showtext)\n\nLoading required package: sysfonts\n\n\nLoading required package: showtextdb\n\nlibrary(scales)\n\n\nAttaching package: 'scales'\n\n\nThe following object is masked from 'package:purrr':\n\n    discard\n\n\nThe following object is masked from 'package:readr':\n\n    col_factor\n\nfont_add_google(name = \"Mountains of Christmas\", family = \"christmas\")\nshowtext_auto()\n\ntheme_set(dark_theme_gray() + \n            theme(title = element_text(family = \"christmas\", size = 20)))\n\nInverted geom defaults of fill and color/colour.\nTo change them back, use invert_geom_defaults().\n\n\n\ngroup_coding |>\n  group_by(group) |>\n  summarise(shared = multi_in(item_list) |> unique(),\n            priority = item_score[shared]) |>\n  group_by(shared) |>\n  summarise(n = n(),\n            group_priority = priority[1],\n            total_priority = sum(priority)) |>\n  ggplot(aes(group_priority, n))+\n    geom_col(fill = \"lightblue\", color = \"white\")+\n    labs(title = \"count of priority groups\")\n\n\n\n\nFigure 1: the number of groups with a given priority\n\n\n\n\n\nknitr::knit_hooks$set(crop = knitr::hook_pdfcrop)\n\n\ngroup_coding |>\n  group_by(group) |>\n  summarise(shared = multi_in(item_list) |> unique(),\n            priority = item_score[shared]) |>\n  group_by(shared) |>\n  summarise(n = n(),\n            group_priority = priority[1],\n            total_priority = sum(priority)) |>\n  arrange(group_priority) |>\n ggplot(aes(\"x\", n))+\n    geom_col(aes(fill = group_priority),\n             color = \"white\",\n             position = \"fill\")+\n    scale_fill_oslo()+\n    labs(title = \"proportion of priority groups\",\n         x = NULL,\n         y = NULL)+\n    coord_polar(theta = \"y\")+\n    theme(axis.text.y = element_blank(),\n          axis.ticks.y = element_blank())\n\n\n\n\nFigure 2: the proportion of groups with a given priority"
  },
  {
    "objectID": "days/2022-12-2.html",
    "href": "days/2022-12-2.html",
    "title": "Day 2",
    "section": "",
    "text": "source: https://adventofcode.com/2022/day/2\nRock paper scissors setup\n\nsessionInfo()\n\nR version 4.2.1 (2022-06-23)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Monterey 12.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.30     jsonlite_1.8.3    magrittr_2.0.3    evaluate_0.17    \n [5] rlang_1.0.6       stringi_1.7.8     cli_3.4.1         renv_0.15.5      \n [9] rstudioapi_0.14   rmarkdown_2.17    tools_4.2.1       stringr_1.4.1    \n[13] htmlwidgets_1.5.4 xfun_0.34         yaml_2.3.6        fastmap_1.1.0    \n[17] compiler_4.2.1    htmltools_0.5.3   knitr_1.40       \n\n\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   0.3.5 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\n\nrock_paper_scissors_outcome <- function(player1, player2){\n  ## Draw score\n  if(player1 == player2){\n    return(3)\n  }\n  ## p2 win conditions\n  else if(player1 == \"rock\" & player2 == \"paper\"){\n    return(6)\n  }else if(player1 == \"paper\" & player2 == \"scissors\"){\n    return(6)\n  }else if(player1 == \"scissors\" & player2 == \"rock\"){\n    return(6)\n  }\n  ## else lose\n  else{\n    return(0)\n  }\n}\n\n\n# testing the function\ntribble(~p1, ~p2,\n        \"rock\", \"rock\",\n        \"rock\", \"paper\",\n        \"scissors\", \"paper\") |>\n  mutate(\n    outcome = map2(\n      p1, \n      p2, \n      rock_paper_scissors_outcome\n      ) |>\n        simplify()\n    )\n\n# A tibble: 3 × 3\n  p1       p2    outcome\n  <chr>    <chr>   <dbl>\n1 rock     rock        3\n2 rock     paper       6\n3 scissors paper       0\n\n\nI’ll use a few different joins to map the first column and the second column to \"rock\", \"paper\" and \"scissors\", and also to map player 2’s move to a score.\n\np1_map <- \n  tribble(\n    ~X1, ~p1,\n    \"A\", \"rock\",\n    \"B\", \"paper\",\n    \"C\", \"scissors\"\n  )\n\np2_map <-\n  tribble(\n    ~X2, ~p2,\n    \"X\", \"rock\",\n    \"Y\", \"paper\",\n    \"Z\", \"scissors\"\n  )\n\nscore_map <-\n  tribble(\n    ~score, ~p2,\n    1, \"rock\",\n    2, \"paper\",\n    3, \"scissors\"\n  )\n\nReading in the data.\n\nstrategy <- read_delim(\n  \"2022-12-2_assets/input.txt\", \n  col_names = FALSE,\n  delim = \" \"\n  )\n\nRows: 2500 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \" \"\nchr (2): X1, X2\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nIt’s just a few joins, then rowwise mapping of the rock_paper_scissors_outcome() function to get the score components. Adding the columns together and summarizing finishes it off.\n\nplay_score <- \n  strategy |>\n    left_join(p1_map) |>\n    left_join(p2_map) |>\n    left_join(score_map) |>\n    mutate(win = map2(\n        p1,\n        p2,\n        rock_paper_scissors_outcome\n      ) |>\n        simplify(),\n      total_score = score + win\n    )\n\nJoining, by = \"X1\"\nJoining, by = \"X2\"\nJoining, by = \"p2\"\n\n\n\nplay_score |>\n  summarise(total_score = sum(total_score))\n\n# A tibble: 1 × 1\n  total_score\n        <dbl>\n1       10624"
  }
]